# -*- coding: utf-8 -*-
"""data_processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OigKNvNguQng4VAZzAeaNEDsn17N0Cmv
"""

from google.colab import drive
drive.mount('/content/drive', True)

import cv2 #to process images
import os #to navegate in files
import shutil #to move files

#Moving images from unlabeled folders to labeled directories
def moveImages(paths: list, savePath: str):
  filepath_images = []
  for fileName in paths:
    for f in os.listdir(fileName):
      if(f[-6] == "_" and (int(f[-5]) >= 0)):
        filepath_images.append(fileName + '/' + f)
  for i in filepath_images:
    shutil.move(i, savePath + str(i[-5]))

  print(f'{len(filepath_images)} labeled images were moved.\n')

#Counting how many labeled/unlabeled images are there
def countImages(paths: list, svPath: str):
  countLabeled = 0
  countUnlabeled = 0
  needMoving = False
  for file_name in paths:
    filepath_images = [f for f in os.listdir(file_name)]
    for i in filepath_images:
      if i[-6] == '_' and (int(i[-5]) >= 0):
        countLabeled = countLabeled + 1
        needMoving = True
      else:
        countUnlabeled = countUnlabeled + 1
  for i in range(10):
    countLabeled = countLabeled + len(os.listdir('/content/drive/MyDrive/NOA/images/' + str(i)))
  print(f'There are {countLabeled} labeled images.\n{countUnlabeled} images left!\n')
  if(needMoving):
    print("There are images outside of their final directory, executing function 'moveImages' to redirect them to their respective folders.")
    moveImages(paths, svPath)
  else:
    print("All images are correctly placed in their respective folders.")

#Counting images
basePath = '/content/drive/MyDrive/NOA/images/no_label_images/'
savePath = '/content/drive/MyDrive/NOA/images/'
paths = [basePath + x for x in os.listdir(basePath)]
countImages(paths, savePath)

#Moving images
basePath = '/content/drive/MyDrive/NOA/images/no_label_images/'
paths = [basePath + x for x in os.listdir(basePath)]

moveImages(paths)

def mp4_to_jpg_sequence(mp4_path: str, data_path: str):
    '''
    mp4_path: string with video path
    data_path: folder where images will be placed
    '''
    print(mp4_path)
    vidcap = cv2.VideoCapture(mp4_path)
    success, image = vidcap.read()
    count = 1
    while success:
        if count%200 == 0:
            cv2.imwrite(f"{data_path}/image_{mp4_path[43:-11]}{count}.jpg", image)
        success, image = vidcap.read()
        count += 1

#Listing every path for each video not processed yet. If it is empty, there are no new videos, but they should be put there daily, until we have enough.
filepath_videos = list(map(lambda x: '/content/drive/MyDrive/NOA/original_videos/' + x, os.listdir('/content/drive/MyDrive/NOA/original_videos')))
filepath_videos

#Converting mp4 files listed above to a set of images of every 200th frame in the videos
for i in range(len(filepath_videos)):
  mp4_to_jpg_sequence(filepath_videos[i], '/content/drive/MyDrive/NOA/images/no_label_images/no_labels_34/')

len(os.listdir('/content/drive/MyDrive/NOA/images/no_label_images/no_labels_34/'))

"""AS IMAGENS GERADAS POSSUEM RESOLUÇÃO 760x760, optei por não mudar a resolução ao salvar os arquivos pra gastar menos tempo, porém quando criarmos o modelo de contagem o ideal será diminuir para algum valor menor como 224x224 (padrão do imagenet e de outros datasets semelhantes), com os generators do tensorflow fica bem fácil de fazer"""